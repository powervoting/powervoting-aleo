import credits.leo;

// The `program` scope defines the data types, functions, and state associated with the `powervoting` program.
program power_voting_v0_2.aleo {

    // current proposals id, like auto-increament id in mysql  // 2074281269322187893875field => current proposal id
    // use 2074281269322187893875field (means "proposals" in string) as the fixed key here
    // TODO: use array instead of mapping when possible
    mapping proposal_ids: field => u64;

    // current votes id, like auto-increament id in mysql  // pid => current vote id
    // TODO: use array instead of mapping when possible
    mapping vote_ids: u64 => u64;

    // proposal info
    struct Proposal {
        title: field,
        content: field,
        options: field,         // append options to field, separator: -&&&&&-, e.g. option1-&&&&&-option2-&&&&&-option3
        vote_type: u8,          // 0: single answer; 1: multiple answers
        expieration: field,     // expieration time, votes will be visiable after this time.
    }

    // proposals will be public for all users, store them into mapping.  // pid => proposal
    mapping proposals: u64 => Proposal;

    struct VoteInfo {
        hash: field,    // votes hash which is generated by encoding vote and options by drand tlock with proposl expieration time
        power: u64,     // voting power
    }

    // votes will be encoded by drand tlock with proposl expieration time, then the encoded hash will be stored into mapping,
    // so that everyone can retrieve the encoded votes to count after proposal expieration time.
    // pvid (pid append current vote id, e.g. pid-vid) => vote info
    // TODO: use array instead of mapping when possible
    mapping votes: field => VoteInfo;

    // vote counts       // pid => option counts, append options counts to field, separator: -&&&&&-, e.g. option1-&&&&&-27-&&&&&-option2-&&&&&-15
    mapping counts: u64 => field;

    // voting power will be private, store them into record.
    record Power {
        owner: address,
        power: u64,             // voting power, default is 1u64
        withdrawable_block_height: u32, // withdrawable block height
    }

    // get voting power for voting, private action
    transition mint_power() -> Power {
        return Power {
            owner: self.caller,
            power: 1u64,    //  defaut 1 power
            withdrawable_block_height: 0u32,    // default can be withdrawed at any time.
        };
    }

    // get voting power for dao management, private action
    transition mint_power_by_credits(credit: credits.leo/credits.record, amount: u64, withdrawable_block_height: u32)
        -> (credits.leo/credits.record, credits.leo/credits.record,Power) {
        let (your_credits, their_change_credits): (credits, credits) = credits.leo/transfer_private(credit, aleo1l44dfmwcu7j2e26yhrlhrxla4lsrmr0rxymxfzxj6h8m2mnegyqs8x0end, amount);
        let power: Power = Power {
             owner: self.caller,
             power: amount,
             withdrawable_block_height: withdrawable_block_height,
         };
       return(your_credits, their_change_credits,power);
    }

    // withdraw token from voting power, private action //todo: update comments
    transition withdraw_credits_from_power(power: Power, credit: credits.leo/credits.record, amount: u64)
        -> (credits.leo/credits.record, credits.leo/credits.record) {
        return credits.leo/transfer_private(credit, self.caller, amount) then finalize(power.withdrawable_block_height);
    }

    // finalize the withdraw feature, if current block height is smaller than power withdrawble_block_height, withdraw will be failed.
    finalize withdraw_credits_from_power(withdrawable_block_height: u32) {
        assert(withdrawable_block_height <= block.height);
    }


    // propose a new proposal, public action.
    transition propose(public title: field, public content: field, public options: field, public vote_type: u8, public expieration: field) {
        // generate proposal
        let proposal: Proposal = Proposal {
            title:title,
            content:content,
            options:options,
            vote_type:vote_type,
            expieration:expieration,
        };
        // finalize the proposal.
        return then finalize(proposal);
    }

    // store proposal into mapping
    finalize propose(proposal: Proposal) {
        let proposal_id_key: field = 2074281269322187893875field;   // means "proposals" in string
        // get proposal id or init with 0
        let pid: u64 = Mapping::get_or_use(proposal_ids, proposal_id_key, 0u64);
        // store proposal into proposals mapping
        Mapping::set(proposals, pid, proposal);
        // update proposal id
        Mapping::set(proposal_ids, proposal_id_key, pid + 1u64);
    }

    // vote on a proposal, private action
    // pid: proposal id
    // pvid: pid append current vote id, e.g. pid-vid. TODO: use array instead of mapping when possible
    // encoded_vote: votes will be encoded by drand tlock with proposl expieration time
    // power: voting power record
    transition vote(pid: u64, pvid: field, encoded_vote: field, power: Power) {
        // power record must belong to the caller
        assert_eq(power.owner, self.caller);
        // generate vote detail
        let vote_info: VoteInfo = VoteInfo {
            hash: encoded_vote,
            power: power.power,
        };
        // finalize the vote
        return then finalize(pid, pvid, vote_info.hash, vote_info.power);
    }

    // store vote info into mapping
    // pvid: pid append current vote id, e.g. pid-vid. TODO: use array instead of mapping when possible
    finalize vote(pid: u64, pvid: field, hash: field, power: u64) {
        // generate vote info
        let vote_info: VoteInfo = VoteInfo {
            hash,
            power,
        };
        // store vote info into mapping
        Mapping::set(votes, pvid, vote_info);
        // update vote id
        let vid: u64 = Mapping::get_or_use(vote_ids, pid, 0u64);
        Mapping::set(vote_ids, pid, vid + 1u64);
    }

    // count a proposal, public action
    // pid: proposl id
    // option_counts: option counts, append options counts to field, separator: -&&&&&-, e.g. option1-&&&&&-27-&&&&&-option2-&&&&&-15
    transition count(public pid: u64, public option_counts: field) {
        return then finalize(pid, option_counts);
    }

    // finalize count
    finalize count(public pid: u64, public option_counts: field) {
        // store counts into mapping
        Mapping::set(counts, pid, option_counts);
    }
}
