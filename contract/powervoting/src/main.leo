
// The `program` scope defines the data types, functions, and state associated with the `powervoting` program.
program powervoting.aleo {

    // power voting token
    record Token {
        owner: address,
        name: field,        // token name, power voting token
        symbol: field,      // token symbol, PVT
        amount: u64,        // voting power, default is 1u64
    }

    // current proposals id, like auto-increament id in mysql  // 2074281269322187893875field => current proposal id
    // use 2074281269322187893875field (means "proposals" in string) as the fixed key here
    // TODO: use array instead of mapping when possible
    mapping proposal_ids: field => u64;

    // current votes id, like auto-increament id in mysql  // pid => current vote id
    // TODO: use array instead of mapping when possible
    mapping vote_ids: u64 => u64;

    // proposal info
    struct Proposal {
        title: field,
        content: field,
        options: field,         // append options to field, separator: -&&&&&-, e.g. option1-&&&&&-option2-&&&&&-option3
        vote_type: u8,          // 0: single answer; 1: multiple answers
        expieration: field,     // expieration time, votes will be visiable after this time.
    }

    // proposals will be public for all users, store them into mapping.  // pid => proposal
    mapping proposals: u64 => Proposal;

    struct VoteInfo {
        hash: field,    // votes hash which is generated by encoding vote and options by drand tlock with proposl expieration time
        power: u64,     // voting power
    }

    // votes will be encoded by drand tlock with proposl expieration time, then the encoded hash will be stored into mapping, 
    // so that everyone can retrieve the encoded votes to count after proposal expieration time. 
    // pvid (pid append current vote id, e.g. pid-vid) => vote info
    // TODO: use array instead of mapping when possible
    mapping votes: field => VoteInfo;     

    // vote counts       // pid => option counts, append options counts to field, separator: -&&&&&-, e.g. option1-&&&&&-27-&&&&&-option2-&&&&&-15
    mapping counts: u64 => field;

    // voting power will be private, store them into record.
    record Power {
        owner: address,
        power: u64,             // voting power, default is 1u64
        withdrawable_block_height: u32, // withdrawable block height
    }


    // get power voting token
    transition mint_token(amount: u64) -> Token {
        return Token {
            owner: self.caller,
            name: 7006912922137281764648909451784002770527598field,   // stands for Power Voting Token string
            symbol: 5264980field,   // stands for PVT string
            amount: amount,
        };
    }

    // get voting power for voting, private action
    transition mint_power() -> Power {
        return Power {
            owner: self.caller,
            power: 1u64,    //  defaut 1 power
            withdrawable_block_height: 0u32,    // default can be withdrawed at any time.
        };
    }

    // get voting power for dao management, private action
    transition mint_power_by_token(token: Token, withdrawable_block_height: u32) -> Power {
        return Power {
            owner: self.caller,
            power: token.amount,
            withdrawable_block_height: withdrawable_block_height,
        };
    }

    // withdraw token from voting power, private action
    transition withdraw_token_from_power(power: Power) -> Token {
        return Token {
            owner: self.caller,
            name: 7006912922137281764648909451784002770527598field,     // stands for Power Voting Token string
            symbol: 5264980field,   // stands for PVT string
            amount: power.power,
        } then finalize(power);
    }

    // finalize the withdraw feature, if current block height is smaller than power withdrawble_block_height, withdraw will be failed.
    finalize withdraw_token_from_power(power: Power) {
        assert(power.withdrawable_block_height <= block.height);
    }


    // propose a new proposal, public action.
    transition propose(public proposal: Proposal) {
        // finalize the proposal.
        return then finalize(proposal.title, proposal.content, proposal.options, proposal.vote_type, proposal.expieration);
    }

    // store proposal into mapping
    finalize propose(public title: field, public content: field, public options: field, public vote_type: u8, public expieration: field) {
        // generate proposal
        let proposal: Proposal = Proposal {
            title,
            content,
            options,
            vote_type,
            expieration,
        };
        let proposal_id_key: field = 2074281269322187893875field;   // means "proposals" in string
        // get proposal id or init with 0
        let pid: u64 = Mapping::get_or_use(proposal_ids, proposal_id_key, 0u64);
        // store proposal into proposals mapping
        Mapping::set(proposals, pid, proposal);
        // update proposal id
        Mapping::set(proposal_ids, proposal_id_key, pid + 1u64);
    }

    // vote on a proposal, private action
    // pid: proposal id
    // pvid: pid append current vote id, e.g. pid-vid. TODO: use array instead of mapping when possible
    // encoded_vote: votes will be encoded by drand tlock with proposl expieration time
    // power: voting power record
    transition vote(pid: u64, pvid: field, encoded_vote: field, power: Power) {
        // power record must belong to the caller
        assert_eq(power.owner, self.caller);
        // generate vote detail
        let vote_info: VoteInfo = VoteInfo {
            hash: encoded_vote,
            power: power.power,
        };
        // finalize the vote
        return then finalize(pid, pvid, vote_info.hash, vote_info.power);
    }

    // store vote info into mapping
    // pvid: pid append current vote id, e.g. pid-vid. TODO: use array instead of mapping when possible
    finalize vote(pid: u64, pvid: field, hash: field, power: u64) {
        // generate vote info
        let vote_info: VoteInfo = VoteInfo {
            hash,
            power,
        };
        // store vote info into mapping
        Mapping::set(votes, pvid, vote_info);
        // update vote id
        let vid: u64 = Mapping::get_or_use(vote_ids, pid, 0u64);
        Mapping::set(vote_ids, pid, vid + 1u64);
    }

    // count a proposal, public action
    // pid: proposl id
    // option_counts: option counts, append options counts to field, separator: -&&&&&-, e.g. option1-&&&&&-27-&&&&&-option2-&&&&&-15
    transition count(public pid: u64, public option_counts: field) {
        return then finalize(pid, option_counts);    
    }

    // finalize count
    finalize count(public pid: u64, public option_counts: field) {
        // store counts into mapping
        Mapping::set(counts, pid, option_counts);
    }
}
