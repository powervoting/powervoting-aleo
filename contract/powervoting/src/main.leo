
// The `program` scope defines the data types, functions, and state associated with the `powervoting` program.
program powervoting.aleo {

    // proposal info
    struct Proposal {
        title: field,
        content: field,
        options: field,         // append options to field, separator: -&&&&&-, e.g. option1-&&&&&-option2-&&&&&-option3
        vote_type: u8,               // 0: single answer; 1: multiple answers
        expieration: field,     // expieration time, votes will be visiable after this time.
    }

    // proposals will be public for all users, store them into mapping.  // pid => proposal
    mapping proposals: field => Proposal;

    struct VoteInfo {
        hash: field,    // votes hash which is generated by encoding vote and options by drand tlock with proposl expieration time
        power: u64,     // voting power
    }

    // votes will be encoded by drand tlock with proposl expieration time, then the encoded hash will be stored into mapping, 
    // so that everyone can retrieve the encoded votes to count after proposal expieration time. 
    // vid (pid append current vote counts) => vote info
    // TODO: use array instead of mapping when possible
    mapping votes: field => VoteInfo;     

    // current votes number  // pid => vote number
    // TODO: use array instead of mapping when possible
    mapping votes_number: field => u64;

    //vote counts       // pid => option counts, append options counts to field, separator: -&&&&&-, e.g. option1-&&&&&-27-&&&&&-option2-&&&&&-15
    mapping counts: field => field;

    // voting power will be private, store them into record.
    record Power {
        owner: address,
        gates: u64,
        power: u64,             // voting power, default is 1u64
    }


    // get voting power, private action
    transition mint_power() -> Power {
        // TODO: get voting power from pledge
        return Power {
            owner: self.caller,
            gates: 0u64,
            power: 1u64,    //defaut 1 power
        };
    }

    // propose a new proposal, public action.
    transition propose(public proposal: Proposal) {
        // generate proposal id.
        let pid: field = BHP256::hash(proposal.title + proposal.content + proposal.options + proposal.expieration);
        // finalize the proposal.
        return then finalize(pid, proposal.title, proposal.content, proposal.options, proposal.vote_type, proposal.expieration);
    }

    // store proposal into mapping
    finalize propose(public pid: field, public title: field, public content: field, public options: field, public vote_type: u8, public expieration: field) {
        // generate proposal
        let proposal: Proposal = Proposal {
            title,
            content,
            options,
            vote_type,
            expieration,
        };
        // store proposal into proposals mapping
        Mapping::set(proposals, pid, proposal);
    }

    // vote on a proposal, private action
    // pid: proposal id
    // vid: vote id, pid append current vote counts. TODO: use array instead of mapping when possible
    // encoded_vote: votes will be encoded by drand tlock with proposl expieration time
    // power: voting power record
    transition vote(pid: field, vid: field, encoded_vote: field, power: Power) {
        // power record must belong to the caller
        assert_eq(power.owner, self.caller);
        // generate vote detail
        let vote_info: VoteInfo = VoteInfo {
            hash: encoded_vote,
            power: power.power,
        };
        // finalize the vote
        return then finalize(pid, vid, vote_info.hash, vote_info.power);
    }

    // store vote info into mapping
    // vid is pid append current vote counts
    finalize vote(pid: field, vid: field, hash: field, power: u64) {
        // generate vote info
        let vote_info: VoteInfo = VoteInfo {
            hash,
            power,
        };
        // store vote info into mapping
        Mapping::set(votes, vid, vote_info);
        // update vote counts
        let number: u64 = Mapping::get_or_init(votes_number, pid, 0u64);
        Mapping::set(votes_number, pid, number + 1u64);
    }

    // count a proposal, public action
    // pid: proposl id
    // option_counts: option counts, append options counts to field, separator: -&&&&&-, e.g. option1-&&&&&-27-&&&&&-option2-&&&&&-15
    transition count(public pid: field, public option_counts: field) {
        return then finalize(pid, option_counts);    
    }

    // finalize count
    finalize count(public pid: field, public option_counts: field) {
        // store counts into mapping
        Mapping::set(counts, pid, option_counts);
    }
}
